Sasha Kharlamov
150707214
skharlamov@myseneca.ca
OOP345-NCC

Workshop 8 Reflection
---------------------

This weeks workshop was not too hard, my main struggle was figuring out how to move
a unique_ptr into a vector, since it is not as simple as using push_back() apparently.
I still don't fully understand why I have to use std::move(*obj) as the push_back 
parameter, but I was getting an error that I was trying to use a deleted function
and this fixed it. 

Smart pointer syntax is definitely far easier on the manual memory management aspect.
My try-catch looks like this when handling raw pointers:

EmployeeWage* temp = new EmployeeWage(emp[i].name, sal[j].salary);
	try {
		temp->rangeValidator();
		activeEmp += temp;
		delete temp;
	}
	catch (std::string& e) {
		delete temp;
		throw e;
	}

Two too many lines in the form of deletes just to make sure that there is no memory leak.
On the other hand, this is the try-catch with smart pointer syntax:

std::unique_ptr<EmployeeWage> temp(new EmployeeWage(emp[i].name, sal[j].salary));
	try {
		temp->rangeValidator();
		activeEmp += std::move(temp);
	}
	catch (std::string& e) {
		throw e;
	}

This is much smaller and cleaner to read. No unnecessary bloated lines that are there
only to handle memory leaks on the off-chance of an error.
All in all, smart pointers just take a good amount of the memory management off your hands
and that is very appreciated.